# Mangers, Risorse e Activities 

Android segue una architettura a **strati**, dove ogni livello offre  servizi a quello superiore nascondendo la complessità del livello inferiore.  

![architettura android](../../images/android_full_arch.png)

1. Hardware:  
    Metallo nudo, sono le componenti fisiche del nostro dispositivo, come processore, memoria, fotocamera ecc... 

2. Linux Kernel:  
    Primo strato di SW, cuore del OS, fa da tramite tra l'hardware e il resto del software, implementa _driver_ che permettono al SW di parlare con l'hardware (camera driver, wifi driver, ecc...)  

3. Libraries & Android Runtime:  
    Le librerie scritte in C++, si occupano di compiti pesanti in modo efficiente (OpenGL per grafica 3D, Webkit per pagine web, SQLite per database)  
    L'Android Runtime è l'ambiente in cui esegue il nostro codice Java/Kotlin.  

4. **Application Framework:**    
    Livello più importante per lo sviluppo mobile, contiene tanti metodi e attrezzi di alto livello che ci permettono di costruire le app astraendo i dettagli dei livelli inferiori, si interagisce con i servizi attraverso i **Manager**.  

5. Applications:  
    Lo strato di più alto livello, è ciò che vede l'utente finale, quindi le applicazioni complete.  



Le applicazioni android sono costruite utilizzando due linguaggi:
1. **XML**: Per definire l'interfaccia grafica (struttura, colori, testi)
2. **Java/Kotlin**: Per definire il comportamento e la logica (es: cosa succede quando clicco un pulsante, come vengono caricati i dati, ...)  

<br><br>

# Manager

Un **Manager** in Android è una classe dell'application framework che agisce come tramite tra la nostra applicazione $\rightarrow$ un servizio specifico del OS, fornisce una API per accedere a questi servizi.  
I manager hanno anche il compito di proteggere le risorse, la nostra app non può liberamente accedere a tutti i dati del nostro dispositivo, per accedere a un determinato servizio deve chiedere i permessi e ottenere un riferimento al manager di quel servizio (se il permesso viene garantito).  

<br>

## Manager Principali:  

### 1. Activity Manager  

È il supervisore del ciclo di vita delle applicazioni, i suoi compiti principali sono:

1. Gestire lo stack delle activity per garantire una navigazione coerenete e prevedibile per l'utente, ogni app messa in primo piano (la sua activity) viene messa in cima allo stack, questo manager gestisce questo stack. 

2. Governare il ciclo di vita: Un'app può essere in primo piano e attiva (`Resumed`), visibile ma non interattiva (`Paused`) oppure in background e non visibile (`Stopped`).  L'activity manager ordina a ogni activity di passare da uno stato all'altro invocando metodi specifici $\rightarrow$ fondamentale per gestire le risorse e memoria.  

3. Gestire le risorse: decide quante risorse allocare per le applicazioni, se in un momento lo stack è grande e le risorse iniziano a scarseggiare allora può decidere di chiudere processi per liberare risorse (tipicamente quelli in fondo allo stack).  


### 2. Package Manager: 

Il package manager conosce tutte le applicazioni installate nel sistema (protegge e interroga il file `packages.xml`), serve a interrogare il sistema per ottenere informazioni su tutti i pacchetti (app) installati.  
Conosce tutte le app e le loro 'intenzioni' (`intent`), sa quindi quali app sono registrate come 'browser web' o 'app per scattare foto'.  
Fondamentale nello sviluppo quando ci dobbiamo appoggiare a servizi di altre app.  

### 3. Window Manager: 

Il window manager è l'amministratore dello schermo, bisogna pensare allo schermo come una serie di fogli trasparenti sovrapposti.  
Gestisce i livelli di profondità: Ogni elemento visuale è una finesta su un 'foglio' separato, il windoww manager sa che ordine devono essere impilati questi fogli.  
Se sono in un app e mi arriva una notifica il window manager disegna il foglio della notifica sopra quello dell'app che sto utilizzando.  


### 4. Connectivity Manager: 

Questo manager è il sensore dello stato della rete del dispositivo, ci permette di: 
- Conoscere lo stato attuale (capire se siamo connessi o meno)
- Essere notificati dei cambiamenti di rete: capire se siamo collegati a WiFi o 4G/3G/... (metered) e 'abbonarci' al manager ci permette di essere notificati se lo stato di rete cambia (es: se da WiFi passiamo a 3G allora la nostra app potrebbe avere della logica che previene il download di file pesanti).  

### 5. Content Provider  

Funge da interfaccia standardizzata per esporre o accedere ai dati delle app $\rightarrow$ permette a un app di esporre i propri dati ad **altre** applicazioni in modo sicuro.  

Un app che vuole condividere i propri dati crea un `ContentProvider` che le altre app useranno come API per accedere ai dati che stiamo espondendo. Le altre app non accedono mai direttamente al database della nostra app, fanno invece richieste al `ContentProvider` che abbiamo creato attraverso metodi standard (query, insert, delete, ...).  
_nota_: Sotto il cofano la comunicazione tra app e content provider avviene tramite il meccanismo di Binder IPC (inter process communication) - il content provider è un astrazione di alto livello.  


Ci sono molti altri Manager, come il Resource Manager (gestisce accesso alle risorse dell'app che non sono codice) e il Location Manager (gestisce GPS).  
In breve i manager sono tutti una misura di sicurezza per una determinata risorsa, controllano l'accesso in quanto per ottenere determinati dati bisogna interfacciarsi con loro ed ottenere un permesso specifico.  


<br><br>


## Resources: 

In Android una risorsa è tutto ciò che _non_ è codice!   

Nello sviluppo in android va affrontato un grande problema, ossia la eterogeneità di dispositivi, le applicazioni non sono progettate per girare su un solo tipo di telefono, ma su migliaia di dispositivi diversi che possono avare schermi di dimensioni diverse, densità di pixel diverse, lingue impostate dall'utente diverse ecc...  

La soluzione di Android è quella di **Separe il codice dalle risorse** - non inseriamo esplicitamente una riga nel codice per "mostrare la scritta `hello`".  
Avremo invece una risorsa che contiene la scritta e che è accessibile da un ID $\rightarrow$ chiederemo al sistema "mostra la risorsa  con ID `saluto` "   

Sarà poi il sistema Android a decidere quale versione di saluto mostrare in base alle caratteristiche del dispositivo in quel preciso momento.  


### Struttura dell'albero delle risorse

![albero risorse android](../../images/resource_tree_android.png)  

All'interno di un progetto avremo: 
- una cartella `src` $\rightarrow$ contine il codice Java/Kotlin
- una cartella `res` $\rightarrow$ contiene tutte le risorse 
 
La cartella `res` è divisa in sottocartelle, ognuna per un tipo specifico di risorsa:  
- layout: contiene file XML che definiscono las truttura dell'interfaccia utente 
- values: contiene file XML per valori semplici (es: strings.xml per testo)  
- drawables: contiene risorse come immagini 

<br>

### qualificatori 

Ricordiamo che il problema principale è quello di dover fornire risorse specifiche in base al dispositvo (e configurazione) su cui sta attualmente eseguendo l'app.   

Per fare ciò si usano i **Qualificatori di Configurazione**  che seuguono questa struttura:

```
<nome_risorsa> - <qualificatore>
```

È importante avere sempre un risorse di default, verranno considerate come tali quelle risorse che non hanno nessun qualificatore.  

I qualificatori si possono usare e combinare a seconda delle necessità, questo permette di avere e creare esperienze utenti gradevoli nonostante la grande etereogeneità dei dispositivi; per garantire questo Android usa un algoritmo per scegliere le risorse migliori, è un processo gerarchico e di eliminazione logica.  

<center>

![algritmo risorse](../../images/algo_risorse_android.png)  

</center>

<br>

## Componenti di un app Android

Programmare per Desktop/Server e per Mobile prevede due approcci diversi, in particolare dato dal limite di risorse e vincoli di batteria dei dispositivi mobili.  

Uno smarthphone seppure potente ha risorse limitate rispetto a un PC, non possiamo sprecare batteria e memoria (RAM) altrimenti l'`ActivityManager` chiuderà la nostra app.  
Inoltre un app può essere interrotta in qualsiasi momento (un utente clicca pulsante home, arriva una chiamata all'utente, ecc...) e le nostre app devono essere progettate per sopravvivere a qesto scenario e interruzioni continue salvando il proprio stato e riprendendo da dove erano rimaste.  

L'**SDK** (**Software Development Kit**) di Andoid fornisce componenti per costruire le nostre app, principalmente dividibili in due macrocategorie:

### 1. Aspetto (come appare l'app)
- **Activities:** Rappresentano una _singola_ schermata dell'interfaccia utente (lista di email è una activity, la lettura di una mail è un'altra activity).  È analogo a un JFrame, possiamo vedere una Activity come un contenitore della finestra principale dentro la quale inseriamo i nostri contenuti. 

<br>

- **Fragments:** Sono delle 'mini-activity' riutilizzabili che possono essere combinate all'interno di una Activity. È una porzione modulare e riutilizzabile dell'interfaccia e ci permette di adattarci a vari dispositivi (consultare immagine).  
    es: su tablet -> c'è abbastanza spazio, allora l'activity A contiene due fragment contemporaneamente: Fragent A (la lista) e Fragment B (il dettaglio), in questo modo quando clicchi un elemento in A si aggiorna il Fragment B.  

    <center>

    ![fragments Android](../../images/fragments_android.png)

    </center>

    Questo mostra la comodità nell'uso di Fragments, scriviamo la logica e il layout per il Fragment A e Fragment B una sola volta, e poi vengono assemblati a seconda dello spazio disponibile $\rightarrow$ possiamo avere file di layour in `res/layout` per telefono e `res/layout-sw600dp` per tablet (dove -sw600dp è il qualifier).  
    Quindi quando lo apriremo sul tablet c'è abbbastanza spazio per contenere i due fragment nello schermo, ma passando a handset (telefono) L'activity A conterrà solo il fragment A e quando si clicca su un suo element si avvia la Activity B che contiene solo il fragment B.   

<br>

- **Views:** Sono i singoli componenti dell'interfaccia, come un bottone, un campo di testo, un immagine,...  
Sono i mattoni base con cui si costruisce l'aspetto di un'Activity o di un fragment.  
Esistono diversi tipi di View (TextView, EditView, Button, ...)  



### 2. Logica (come funziona l'app)
- **Bundles:** Sono oggetti simili a dizionari usati per passare dati tra componenti, ad esempio da un'Activity a un altra, o per salvare lo stato di un Activity quando viene interrotta.  

<br>

- **Intents:** Sono messaggi che un componente può inviare per richiedere un'azione a un altro componente (anche di un altra app volendo).  Quando la nostra app vuole aprire una pagina web, non dobbiamo implementare un browser $\rightarrow$ creeremo un intent che dice 'voglio visualizzare questo URL' e lo invieremo al sistema, l'ActivityManager lo intercetta e avvierà il browser web che l'utente sceglierà (o che ha scelto di default).   

<br>

---

<br>


### Costruire una View:

Una View ha attributi (larghezza, altezza, colore di sfondo,...) ed è organizzata in ViewGroups (layout).  
Possiamo costruire una View in 3 modi:
1. Da file XML: modo preferito di costruirle in quanto si definisce la view e tutti i suoi attributi, separa l'aspetto dalla logica ed è più facilmente manutenibile.  
2. Da editor drag&drop: AndroidStudio mette a disposizione un editor di questo tipo, alla fine non fa altro che scrivere il file XML per noi.  
3. Programmaticamente: Sconsigliato a meno che sia indispensabile e il programmatore sappia bene cosa sta facendo.  


### Sintassi XML:

- `android:<nome_proprietà>=<valore>` è la sintassi base

- `@<tipo_risorsa>/<id_risorsa>` è il modo per fare riferimento a una risorsa   

    <br>
    
    es: `android:text="@string/button_label_next`
    
    significa: per il testo di questo bottone vai a prendere il valore della risorsa di tipo `string` chiamata `button_label_next` (consente la traduzione in base alla lingua del dispositivo)  

- `="@+id/<nuovo_id>"` è la sintassi per definire un nuovo ID per una View, l'ID è fondamentale perchè ci permette di travera questa specifica View nel nostro codice Java/Kotlin per poterla manipolare (es:legare un evento al suo click).   


### Proprietà di una TextView:  
Si possono impostare da file XML o programmaticamente  
- File XML: attraverso attributi, per esempio per una TextView potremmo avere  
    android:text; android:textColor; android:textSize; ... 

- Programmaticamente: 

```Java
TextView textView = new TextView(this); 
textView.setText("Testo di prova");
```

Crea un oggetto `TextView`, la keyword `this` è fondamentale e si riferisce al **contesto**, che è un oggetto che fornisce accesso a risorse e servizi globali di sistema.  
una View ha bisogno di un contesto per sapere quale tema grafico usare o come accedere alle risorse e siccome una Activity è un Context, passiamo `this`.  



**nota:** Il `Context` è un oggetto che agiscecome un ponte tra il componente dell'app e l'ambiente del sistema operativo, fornisce accesso a informazioni e servizi a livello di applicazione
- dove trovo le risorse (immagini, stringhe, ecc...)
- come lancio una nuova activity
- come accedo a un servizio di sistema (es. connectivity manager)
- in quale cartella del dispositivo salvo i file privati 


<br>

---

<br>

### Views e Layouts 

Abbiamo spiegato come creare le nostre Views (che sono i mattoni singoli), ora dobbiamo capire come disporre di queste views.  
Dobbiamo prestare particolare attenzione e assicurarci che la disposizione si adatti bene a schermi di dimensioni e orientamenti diversi, per fare ciò usiamo proprio i Layout.   

In Android la disposizione di componenti è gestita da contenitori speciali chiamati **Layouts**, che in realtà sono delle view invisibili il cui unico scopo è organizzare le view figlie che contiene, secondo specifiche regole.  

Concetti chiave: 
- Non disponiamo le view in modo assoluto ma le inseriamo dentro un layout al quale indicheremo come deve gestirle. 
- L'uso dei layout è fondamentale per creare interfacce flessibili che si adattano a diversi display.  
- Possiamo annidare i layout (strutture nested o ad albero): potremmo avere un layout verticale principale che al suo interno contine un layout orizzontale (per due bottoni) e sotto di esso contine un altro layout a griglia (per visualizzare immagini).  La struttura ad albero è importantissima per costruire UI complesse.  
- Si possono definire tramite IDE/XML (consigliato) o prgrammaticamente (sconsigliato).  


### Classi di Layout: 

1. `LinearLayout`: È il più semplice, dispone i suoi figli in un'unica riga orizzontale o verticale
2. `RelativeLayout`: Più complesso ma molto potente, posiziona i figli in relazione _tra loro_ (metti bottone x sotto bottone y) adattandoli.  
3. `GridLayout`: Dispone i figli in un unica griglia rettangolare 
4. `TableLayout`: Simile alla griglia ma organizza i figli in righe e colonne
5. `ConstraintLayout`: È l'evoluzione del RelativeLayout e considerato ad oggi da Google come il layout più importante e flessibile.  

<center>

![tipi di layout](../../images/layout_types_for_views.png)

</center>


### Portabilità dei Layout:

Per costruire Layout che funzionano bene su ogni dispositivo dobbiamo usare unità di misure strandardizzate, in particolare useremo:

1. **dp (Density Independent Pixel)** : È l'unità di misura che va usata _sempre_ per definire le dimensioni dei layout e delle view. Un `dp` è un unità astratta che non dipende dalla densità di pixel del dispositivo, assicura che un pulsante di 160dp sia della stessa dimensioni su qualsiasi schermo, il OS si occupa di fare la conversione matematica per assicurare questa cosa.  
2. **cp (Scalable Pixel)** : È identico al dp ma rispetta anche la dimensioni del testo preferita dall'utente $\rightarrow$ va usato ogni volta che abbiamo del testo nella nostra app!


