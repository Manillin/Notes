# Cache Memory


## 1. Anatomia dell'Indirizzo e della Cache

La CPU lavora con indirizzi virtuali/fisici (es. 32 bit). La Cache non vede l'indirizzo come un blocco unico, ma lo scompone in tre parti fondamentali.

$$Indirizzo (32 bit) = [ TAG \ \mid \ INDEX \ \mid \ OFFSET ]$$

### A. I Componenti

1.  **OFFSET**
    *   **Cos'è:** Indica *quale byte* all'interno della linea di cache vogliamo leggere.
    *   **Es:** *"Se ho una linea da 16B, significa che dentro possono starci 4 indirizzi da 4B (interi)"*
    *   **Calcolo:** $Bit_{Offset} = \log_2(\text{Dimensione Linea in Byte})$.
    *   **Località Spaziale:** Quando carichi un dato, carichi l'intera linea (es. 16 Byte). I vicini vengono caricati "gratis".

2.  **INDEX (Indice)**
    *   **Cos'è:** È il puntatore che ci dice *in quale riga* (o Set) della cache dobbiamo andare a guardare. È l'indirizzo della "scatola".
    *   **Calcolo:** $Bit_{Index} = \log_2(\text{Numero di Righe o Sets})$.

3.  **TAG (Etichetta)**
    *   **Cos'è:** È il documento di identità del dato. Serve a confermare se il dato trovato all'Index specificato è *davvero* quello che cercavamo o un altro che è capitato lì per caso.
    *   **Calcolo:** Bit rimanenti ($32 - Index - Offset$).

### B. Struttura Fisica: Dove stanno i dati?

*Dati* e *controlli* sono separati. La cache è composta da due memorie parallele:

1.  **Data Array (La Matrice dei Dati):** Contiene i blocchi veri e propri (es. i 16 Byte). Qui non ci sono indirizzi, solo valori.
2.  **Tag Directory (La Memoria di Supporto):** È affiancata ai dati.
    *   **Cosa salva:** Salva **SOLO il TAG** e i bit di stato (Valid, Dirty).
    *   **Cosa NON salva:** Non salva l'Index (perché l'Index è l'indirizzo della riga stessa) e non salva l'Offset (perché l'Offset serve solo a scegliere il byte dopo la lettura).

---

## 2. Direct Mapped vs. N-Way Associative

### Direct Mapped (Mappatura Diretta)
*   **Logica:** Ogni indirizzo di memoria ha **UN SOLO** posto possibile nella cache, determinato dall'Index.
*   **Metafora:** Un hotel dove la Stanza 101 ha **1 solo letto**.
*   **Eviction (Sfratto):** Se due variabili (`var1` e `var3`) hanno lo stesso Index ma Tag diverso, si "prendono a calci".
    *   Arriva `var3` -> Trova `var1` -> **Conflitto immediato** -> `var1` viene buttata fuori.
*   **Problema:** Alto tasso di miss da conflitto (Thrashing) anche se la cache è vuota altrove.

### N-Way Set Associative (Associativa a N Vie)
*   **Logica:** L'Index non punta più a una singola riga, ma a un **Insieme (SET)**. Ogni Set contiene **N Linee (Vie)**.
*   **Metafora:** Un hotel dove la Stanza 101 è una suite con **N letti**.
*   **Vantaggio:** Due variabili con lo stesso Index possono convivere pacificamente in vie diverse dello stesso Set.
*   **Geometria:** Rispetto alla Direct Mapped (a parità di dimensione totale):
    *   I Sets sono meno delle Linee totali ($Sets = Linee / N$).
    *   L'**Index diminuisce** di bit.
    *   Il **Tag aumenta** di bit.

---

## 3. Risoluzione Esercizio Passo-Passo

**Dati Comuni:**
*   Cache: 1 MB ($2^{20}$ B)
*   Linea: 16 Byte ($2^4$ B) -> **Offset = 4 bit**
*   Indirizzi Hex:
    *   `var1` (F000A023) -> Tag `F00...`
    *   `var2` (F000A021) -> Tag `F00...` (Stesso blocco di var1)
    *   `var3` (A000A022) -> Tag `A00...` (Blocco diverso)
    *   `var4` (F000A025) -> Tag `F00...` (Stesso blocco di var1)

### Parte A: Direct Mapped

1.  **Geometria:**
    *   Linee = $2^{20} / 16 = 2^{16}$.
    *   **Index = 16 bit** (`0A02` per tutte le variabili).
    *   **Tag = 12 bit**.

2.  **Simulazione Iterazione 1:**
    *   `var1` (F...): Cache vuota. **Miss Compulsory**. Carico F. (Cache: `[F]`)
    *   `var2` (F...): Tag F c'è. **Hit**.
    *   `var3` (A...): Tag F occupa la riga. Conflitto. **Miss Compulsory**. Butto F, carico A. (Cache: `[A]`)
    *   `var4` (F...): Tag A occupa la riga. Conflitto. **Mis Conflict**. Butto A, carico F. (Cache: `[F]`)

3.  **Iterazioni successive:**
    *   Si ripete il ciclo di conflitti tra `var3` e le altre.
    *   Risultato: **2 Hit, 2 Miss** per ciclo.

### Parte B: 2-Way Set Associative

1.  **Geometria:**
    *   Sets = $2^{16} / 2 = 2^{15}$.
    *   **Index = 15 bit**.
    *   **Tag = 13 bit** (aumenta di 1).

2.  **Analisi:** Tutte le variabili cadono nello stesso Set, ma abbiamo solo **2 Blocchi unici** in gioco: il blocco `F...` (per var1, var2, var4) e il blocco `A...` (per var3). Il Set ha 2 vie, quindi **ci stanno entrambi**.

3.  **Simulazione Iterazione 1:**
    *   `var1` (Blocco F): Set vuoto. **Miss**. Metto F in Via 0.
    *   `var2` (Blocco F): C'è in Via 0. **Hit**.
    *   `var3` (Blocco A): Via 0 occupata, Via 1 libera. **Miss**. Metto A in Via 1.
    *   `var4` (Blocco F): C'è in Via 0. **Hit**. *(Nota: Qui non c'è sostituzione perché var1 e var4 sono lo stesso blocco!)*.

4.  **Iterazioni Successive (2-10):**
    *   Il Set contiene `[ Via 0: F ] [ Via 1: A ]`.
    *   Tutte le variabili trovano il loro Tag.
    *   **4 Hit, 0 Miss**.

---

## 4. LRU

Abbiamo visto che nella 2-Way, con i blocchi `F00` e `A00`, la cache è piena ma stabile. Quando avviene una **vera Conflict Miss** con sostituzione LRU?

**Scenario:**
Il Set `0A02` è pieno:
*   Via 0: Tag `F00` (usato recentemente)
*   Via 1: Tag `A00` (usato meno recentemente)

**Arriva un nuovo accesso:** `var5` all'indirizzo `D000A020`.
1.  **Index:** `0A02` (Stesso Set).
2.  **Tag:** `D00` (Nuovo!).
3.  **Controllo:** L'hardware cerca `D00` nel Set. Non c'è. Le vie sono piene.
4.  **Risultato:** **CONFLICT MISS**.

**Intervento della Policy LRU (Least Recently Used):**
L'hardware deve fare un'**EVICTION** (Sfratto).
*   Controlla i bit LRU: chi tra `F00` e `A00` non viene toccato da più tempo?
*   Supponiamo sia `A00`.
*   **Azione:**
    1.  Elimina il Tag `A00` dalla Via 1.
    2.  Elimina l'intero blocco di dati (16 Byte) associato ad `A00`.
    3.  Scrive il Tag `D00` nella Via 1.
    4.  Carica i 16 Byte del blocco `D...` nella Via 1.

**nota fondamentale:** 
L'eviction lavora sempre a livello di linea (Blocco), mai a livello di singola variabile (Word).  
