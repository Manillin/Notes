# Multi Threading in Java/Kotlin

Molte delle applicazioni moderne sfruttano l'architettura a più core delle CPU attraverso i Thread, non si esegue un programma unicamente in modo sequenziale, in specifici casi dividere il lavoro in più thread torna estremamente utile e velocizza l'applicazione in questione.  

Consideriamo un app con una interfaccia grafica contenente un pulsante, una volta cliccato un pulsante dobbiamo fare una operazione lunga e complessa.  
Se siamo nel paradigma single thread, allora una volta cliccato il pulsante la GUI si blocca fino a quando la computazione lunga non è terminata, non è il comportamento che vorremmo.  

La soluzione di base in Java è l'utilizzo dei Thread

### Threads

Il mattone fondamentale è la classe `Thread`, possiamo creare una nostra classe che estende Thread per definire un compito che deve essere eseguito in parallelo.  
Il codice di questo compito va inserito all'interno del metodo speciale `run()`.   


<center>

Esempio uso classe Thread:

</center>

  
Creiamo classe ThreadEX che andrà nel suo file dedicato (ThreadEX.java), estenderà la classe Thread e il calcolo lungo verrà inserito nel metodo `run()`  

```java
public class ThreadEX extends Thread{
    public int startingNumber;
    private int numDivs;

    public ThreadEX(int startingNumber){
        this.startingNumber = startingNumber;
    }

    @Override
    public void run(){
        int div=2;
        for(int i=2; i<startingNumber; i++)
            if( (startingNumber % i) == 0)
            div++;
        numDivs = div;
    }

    public int getNumDivs(){ return numDivs; }
}
```


Creiamo la classe che sfrutterà i thread, andrà nel suo file dedicato (MainTester.java).  

```java
public class MainTester {
    public static void main(String[] args) {
        ThreadEX tex1 = new ThreadEX(1000);
        ThreadEX tex2 = new ThreadEX(1105);
        tex1.start();
        tex2.start();
        try {
            tex1.join();
            tex2.join();
            System.out.println("Tex 1 divs : " + tex1.getNumDivs());
            System.out.println("Tex 2 divs : " + tex2.getNumDivs());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

Questo esempio risolve parzialmente il problema dei thread, in quanto presenta dei forti limiti in un contesto grafico:
1. **Manca la separazione Grafica/Logica:** il calcolo risulta separato ma non esiste un modo per fare comunicare i due mondi, il thread di calcolo non riesce a dire al thread grafico che ha finito e che deve aggiornare la GUI.  
2. **Nessun feedback sul progresso:** il metodo `join()` forza l'attesa della computazione del thread, non abbiamo un modo di sapere se il calcolo è al 10%, al 80% o al 99%.  
3. **Boilerplate code:** Per gestire comunicazione e aggiornamenti tra thread dovremmo implementare manualmente un sistema di osservatori e ascoltatori, diventerebbe eccessivamente verboso.  


In conclusione, i Thread nudi non dispongono di un modo strutturato per gestire i risultati e gli aggiornamenti, diventando poco utili in un contesto grafico.  
Java mette a disposizione strumenti più avanzati per gestire i thread ad un livello più alto di astrazione. 


<br>


### Il pacchetto `java.util.concurrent` e `FutureTask\<Callable V>`



Abbiamo la seguente necessità per i Thread:

1. Chiedere in qualsiasi momento se ha finito la computazione 
  
2. Una volta che ha finito ottenere il risultato del suo calcolo 

La classe Thread di base non offre un modo diretto per ottenere un valpre di ritorno (il metodo run() restituisce void).  





