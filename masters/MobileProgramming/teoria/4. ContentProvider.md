# Content Provider

Ogni app android vive in una sandbox isolata (per motivi di sicurezza), significa che di default le app non possono leggere i file di altre app.  
È assolutamente necessario disporre di un meccanismo per condividere dati tra applicazioni, ed è qui che entra in gioco il **Content Provider**, che consiste in una forma standardizzata, sicura e controllata di accedere ai dati delle altre app.  



<center>

![architettura content provider](../../images/architettura_content_provider.png)

</center>


- I dati delle altre app vivono nel `DataLayer` (database privati)
- Il content provider si trova al `DataAccessLayer` ed è l'unica interfaccia pubblica e controllata verso i dati
- Le app vivono nel `ApplicationLayer` e per leggere dati delle altre app devono fare richiesta tramite il content provider, che si accerterà che le app dispongano dei permessi necessari per permettere questa operazione.  

Il content provider lo possiamo vedere come un server nell'app di destinazione, la comunicazione tra l anostra app (client) e l'app che ospita il server provider (server) avviene tramite meccanismi di basso livello di comunicazione tra processi (IPC), il content provider è un'astrazione di questo meccanismo che ci nasconde la complessità.  


### Package Manager:  

Il `PackageManager` ci permette di sapere quali applicazioni abbiamo nel sistema e lo possiamo usare anche per sapere quali `ContentProvider` sono disponibili sul telefono.  


```java
// Ottieni un riferimento al PackageManager
List<ProviderInfo> providers = getPackageManager().queryContentProviders(null, 0, 0);

// Scansiona la lista dei risultati
for (ProviderInfo pi : providers) {
    Log.d(TAG, "Provider : " + pi.authority + " " + pi.readPermission);
}
```

- `pi.authority`: l'authority è un nome univoco che identifica senza ambiguità un ContentProvider
- `pi.readPermission`: ci dice quale permesso deve avere la nostra app per poter leggere i dati da questo provider  


### Content Resolver:  

Il ContentResolver è colui che invia la API, chiama l'authority (aka il nome esatto) del content provider e invia le nostre richieste.   
Ci fornisce una interfaccia con i metodi CRUD per interagire con i dati.  

**nota:**  
- `ContentProvider` $\rightarrow$ vive nell'app che _possiede_ i dati (app server)
- `ContentResolver` $\rightarrow$ vive nella nostra app, quella che _vuole accedere_ ai dati (app client)  


Il metodo più comune per usare un contentResolver è attraverso la clausola `query()` che corrisponde a una lettura.  

```java
// 1. L'INDIRIZZO (FROM table)
Uri table = ContactsContract.CommonDataKinds.Phone.CONTENT_URI;

// 2. LE COLONNE CHE VOGLIAMO (SELECT column)
String[] projection = new String[]{ ContactsContract.CommonDataKinds.Phone.NUMBER };

// 3. LA CONDIZIONE DI FILTRO (WHERE clause)
String selectionClause = ContactsContract.Contacts.DISPLAY_NAME + " = ?";

// 4. I VALORI PER IL FILTRO
String selArgs[] = new String[]{"Mario Rossi"};

// 5. ESEGUIRE LA QUERY
Cursor c = getContentResolver().query(table, projection, selectionClause, selArgs, null);
```


In SQL corrisponde a:

```SQL
SELECT NUMBER from PHONE
WHERE display_name = "Mario Rossi"
```  

- `CONTENT_URI`: costante predefinita che ci dà l'indirizzo esatto della tabella dei numeri d itelefono all'interno del Content Provider dei contatti.  
- `projection`: ci permette di specificare il dato che ci interessa (Phone.NUMBER) 
- `selectionClause = ?`: il '?' serve come placeholder sicuro (evitare SQL injections)
- `selArgs`: valore che sostituirà il '?'
- `getContentResolver().query(...)`: metodo che fa la chiamata vera e propria al content provider che ci interessa.  
- `Cursor c`: corrisponde a un oggetto di tipo puntatore, si posiziona sulla tabella dei risultati. Per leggere i dati dobbiamo scorrere questo cursore riga per riga ed estrarre i valori dalle colonne che abbiamo richiesto  

